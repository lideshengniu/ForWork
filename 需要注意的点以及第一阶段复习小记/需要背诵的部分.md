# 1.基础部分

## 1.undefined 和 null的区别

```js
在实践中，null 通常被用于初始化一个变量，以表示该变量将被稍后赋予一个对象值，或者用于故意标记变量为“无值”。而 undefined 则表示变量在被访问之前还没有被赋值，或者函数没有返回任何值。
```

## 2.基础数据类型

```js
String Number Null Undefined Boolean Symbol BigInt

```

### 1."周".localeCompare("秦" )

```js
'周'.localeCompare("秦") //1
'秦'.localeCompare("周") //-1
'秦'.localeCompare("秦") //0
```



### 2.三元运算符中不能出现continue break return这些关键词

```js
this.substr(i,lenT)=== T? res = i,break:null
```

### 3.Symbol

```js
Symbol('123') === Symbol('123') //false
typeof Symbol("123") //"symbol"
```

### 4.NaN

```js
let a = NaN
a === a   //false
```



## 3.元素获取方法

```js
1.querySelector
2.querySelectorAll
3.getElementsByTagName
4.getElementsByClassName
5.getElementsByName
6.getElementById
并且 getElementById 和 getElementsByName 是document才能的
```

## 4.全局作用域的不同叫法

```JS
全局作用域
全局执行上下文
全局栈内存
对了三元运算符如果有多个行为 
condition ? (a = 1, console.log('b'), b = 'assigned') : a = 0; 用括号括起来 需要多的步骤加逗号
```

### 1 作用域链的定义

```js
作用域链的定义如下：

每个JavaScript函数在创建时都会附带一个所谓的作用域链。这个作用域链是一个对象列表，列表中的对象包含了函数可以访问的所有变量。作用域链的创建和函数的词法作用域有关，即函数在代码中被定义的位置。
```

## 5. let和var

### *建变量的六种方式中：var/function 有变量提升，而let/const/class/import都不存在这个机制*

```js
let vs var
1.let没有变量提升(但是再词法解析阶段也得知某个变量是否是私有变量)
2.let 不允许再相同的作用域下重复声明
3.let 解决了js暂时性死区问题
4.let创建的全局变量没有给window设置对应的属性
5.let会产生块级作用域
```

## 6.Array.from

```JS
是的，Array.from() 方法在JavaScript中可以用来将类数组对象（拥有 length 属性和索引元素）或可迭代对象（如 Map 和 Set）转换成真正的数组
```

## 7.箭头函数

```js
ChatGPT
在JavaScript中，"use strict"是一个指令，用于将整个脚本或单独的函数置于“严格模式”下的执行。严格模式是一种较为严格的JavaScript运行环境，目的是使代码更加健壮和错误更易于检测。在严格模式下，一些原本被忽略的错误会被抛出，并且有些对代码安全性有潜在风险的行为也会被禁用。

以下是在严格模式下有所不同或被禁止的行为：

变量必须声明：不能对未声明的变量赋值。
静态绑定：this 值不会被自动绑定到全局对象，而是保持为undefined（在非方法的函数中）。
禁止使用with语句：with被认为会导致混淆的作用域并且难以优化。
赋值给不可写属性会抛出错误：在严格模式下，给只读属性赋值会抛出错误。
禁止删除不可删除的属性：删除不可配置的对象属性会抛出错误。
禁止重复的对象字面量属性：在对象字面量中重复的属性名是不允许的。
禁止重复的参数名：函数不能有重名的参数。
禁止八进制字面量：像 0123 这样的八进制字面量在严格模式下是不合法的。
禁止设置eval或arguments为变量或参数的值：不能将 eval 或 arguments 赋值给其他变量或参数。
限制eval和arguments的使用：eval和arguments不能被赋值、不能用作变量名或函数名，且有自己的作用域。
arguments对象的行为变化：arguments对象不再追踪参数的变化。
禁止在函数声明中使用删除操作符：不能删除函数。
必须使用错误声明的构造函数：比如 throw new Error('message')，而不是 throw 'message'。
要启用严格模式，你可以在脚本或函数的开头添加 "use strict"; 声明：

javascript
Copy code
"use strict";

function doSomething() {
  // 代码在这里会以严格模式执行
}
或者，仅对单个函数启用严格模式：

javascript
Copy code
function doSomething() {
  "use strict";
  // 该函数的代码在这里会以严格模式执行
}
严格模式有助于提前捕获潜在的错误和不安全行为，这样可以避免一些常见的JavaScript陷阱。随着ECMAScript的发展，许多严格模式的限制已经成为了语言标准的一部分。
```

## 8. A标签

```js
  <!-- A标签第一个作用：超链接 -->

    <!--    <a href="http://www.baidu.com"></a>
   <a href="http://www.baidu.com" target="_blank" >珠峰培训</a>


  <!-- A标签第二个作用：锚点定位 -->
    <a href="#box">哈哈</a>
    <div id="box">呵呵</div>


  <!--A标签第三个作用  href="javascript:;" 阻止A标签的默认行为 -->
    <a href="javascript:;">我就是个按钮</a>
```

### 1.js阻止默认行为

用来处理字符串的规则

\- 只能处理字符串

\- 它是一个规则”可以验证字符串是否符合某个规则（test），也可也把字符串中符合规则的内容捕获到（exec/match...)

```js
  //js阻止默认行为
      link.onclick = function (ev) {
        //1 让ev事件对象取消默认事件
        // ev.preventDefault()
        //2 或者返回一个false也可以 二选一
        //return false
      };
```

## 9.正则

```JS
1.量词元字符
* 零到多次
+ 一到多次
? 零次或者一次
{n} 出现n次
{n,} 出现n到多次
{n,m}出现n到m次
2.特殊元字符 单个或者组合一起代表特殊含义
\ 转义字符
. 除了\n(换行符) 之外的任意字符
^ 以什么开头
$ 以什么结尾
\n 换行符
\d 0-9之间的一个数字
\D 除了0-9
\w 数字、字母、下划线中的任意一个字符
\W 和\w相反
\s 一个空白字符(包含空格、制表符、换页符等)
\S 非空白字符
\t 一个制表符(一个tab 四个空格)
\b 匹配一个单词的边界
x|y x或者y
[xyz] xyz中的一个字符
[^xy] 除了x/y以外的任意字符
[a-z] a到z这个范围 [0-9a-zA-Z_] ===\w
[^a-z] 非a-z中的一个
()正则中的分组符号
(?:) 只匹配不捕获
(?=)正向预查
(?!)负向预查
i忽悠大小写
m可以进行多行匹配
g全局匹配
```

## 10.class

```js
class Point {
  constructor() {
    // ...
  }

  toString() {
    // ...
  }

  toValue() {
    // ...
  }
    // 给实例设置的私有属性
  y = 200;
    //直接写的方法就是加在原型上的 === Fn.prototype.getX..
  //前面设置static的，把当前Fn当作普通对象设置的键值对
  static queryX() {}
  static x = 100;
}

// 等同于

Point.prototype = {
  constructor() {},
  toString() {},
  toValue() {},
};
===============
    由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign()方法可以很方便地一次向类添加多个方法。

class Point {
  constructor(){
    // ...
  }
}

Object.assign(Point.prototype, {
  toString(){},
  toValue(){}
});

Point.prototype.constructor === Point // true
=============
    另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。
========
    class Point {
  constructor(x, y) {
    // ...
  }
  toString() {
    // ...
  }
}
Object.keys(Point.prototype)
// []
Object.getOwnPropertyNames(Point.prototype)
==============
    ============
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  toString() {
    return '(' + this.x + ', ' + this.y + ')';
  }
}

var point = new Point(2, 3);

point.toString() // (2, 3)

point.hasOwnProperty('x') // true
point.hasOwnProperty('y') // true
point.hasOwnProperty('toString') // false
point.__proto__.hasOwnProperty('toString') // true
```

## 11.居中处理

```js

        /* 第一种 */
        /*    position: absolute;
        top: 50%;
        left: 50%;
        margin-left: -150px;
        margin-top: -150px; */
   
       /* 第二种 */
      /* .box {
        position: absolute;
        top: 50%;
        left: 50%;
       // 基于css3中的位移，在不知道宽高的情况下也能实现效果
        transform: translate(-50%, -50%);
      } */


/* 第三种    margin auto auto //是水平居中 上下并不是居中所以这里需要设置
         position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        margin: auto auto;
      
      */
   /* 第四种 
           父亲设置display:flex
            justyify-content:center;
            align-items:center
      */
```

## 12.闭包

```JS
1.创建函数

- 开辟一个堆内存
- 把函数体中的代码当作字符串存储进去
- 把堆内存的地址赋值给函数名/变量名
- **函数在哪创建，那么它执行时候所需要查找的上级作用域就是谁**
2.函数执行

- 形成一个全新的私有作用域、执行上下文、私有栈内存(执行一次形成一个，多个之间也不会产生影响)
- 形参赋值and变量提升
- 代码执行（把所属堆内存中的代码拿出来一行一行执行）
- **遇到一个变量，首先看它是否是为私有变量（形参和在私有作用域中声明的变量是私有变量）是私有的就操作之间的变量即可，不是私有的则向上级作用域中查找。。一直找到全局作用域为止=》作用域链查找机制**
- 私有变量和外界的变量没有必然关系，可以理解为被私有栈内存保护起来了，这种机制其实就是**闭包的保护机制**
 
```



### 1.栈内存

```js
// 打开浏览器形成的全局作用域是栈内存
// 手动执行函数形成的私有作用域是栈内存
// 基于es6中的let/const形成的块作用域也是栈内存
  
  /*
   *全局栈内存：关掉页面的时候才会销毁
   *私有栈内存：
      1.一般情况下，函数只要执行完成，形成的私有栈内存就会被销毁释放掉（排除死递归、出现死循环的模式）
      2.但是一旦栈内存中的某个东西（一般都是堆地址）被私有作用域以外的事物给占用了，则当前私有栈内存不能立即被释放销毁（特点：私有作用域中的私有变量等信息也被保留下来了）=》市面上认为的闭包：函数执行形成不能被释放的私有栈内存，这样的才是闭包
     */
```



### 2.闭包的两大作用

```js
从性能角度讲，我们真实项目中应该减少堆闭包的使用(因为闭包会产生不释放的栈内存，过多使用容易导致内存溢出或者性能降低)

 1.保护（私有变量和外界没有必然联系）
 2.保存（形成不销毁的栈内存，里面的私有变量等信息保存下来了）
```

## 13. 逻辑或 || 和 逻辑与 && 在赋值

```js
A || B 先验证A的真假，如果A为真，返回的是A的值，如果A为假返回的是B的值
 A&&B ： A为真返回B的值，A为假返回A的值
 &&的优先级高于||
 let a = 0 || false
 console.log(a) //false

 a = 1 || false
 console.log(a) //1

 a=1 && 100
 console.log(a) // 100

 a = 0 && 100
 console.log(a) // 0

 a = 0 || 1 && 2||3 //先算1&&2
 console.log(a) //2
```



# 2.需要重写的方法

## 2.1 判断是否是公有方法

```js
Object.prototype.hasPubProperty = function (property) {
  let somes = ['string', 'number', 'boolean'];
  let y = typeof property;
  if (!somes.includes(y)) {
    return false;
  }
  let n = property in this,
    b = this.hasOwnProperty(property);
  return n && !b;
};
```

## 2.2 数组去重

```js
(function () {
  function myUnique() {
    let obj = {};
    let arr = [];
    for (let i = 0; i < this.length; i++) {
      this[i] in obj
        ? ((this[i] = this[this.length - 1]),
          this.length--,
          this.splice(i, 1),
          i--)
        : (obj[this[i]] = this[i]);
    }
    return this;
  }
  Array.prototype.myUnique = myUnique;
})();
```

## 2.3重写call apply

```js
~(function () {
  /* call:改变函数中的this指向
     @params
       context 可以不传递，传递必须是引用类型值(因为后面要给它加$fn的属性) 
     
    */

  function call(context) {
    // this:sum 也就是当前要操作的这个函数实
    context = context || window;
    let args = [], //除第一个参数外剩余传递的信息值
      result;
    for (let i = 1; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    // 这里arguments不能用slice来排除第一个参数因为 只是类数组没有slice方法 只能用for
    context.$fn = this;
    result = context.$fn(...args); //args=[10,20]...是ES6中的展开运算符，把数组中的每一项分别的展开传递给函数// context.$fn(10,20)
    delete context.$fn;
    return result;
  }
  //扩展到内置类的原型上  这样会覆盖原有的call方法
  Function.prototype.call = call;
})();
```

## 2.4汉字

```js
 1.汉字 /^[\u4E00-\u9FA5]$/
```

## 2.5 exec的全捕获完善代码

```js
~(function(){
    function execAll(str=""){
        if(!this.global) return this.exec(str)    }
    let ary = [],
        res = this.exec(str);
    while(res){
        ary.push(res[0])
        res = this.exec(str)
    }
    return ary.length === 0 ? null:ary;
}
  RegExp.prototype.execAll = exceAll
  }
 )()
```

# 

