<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      //   let str = 'zhufeng2019yangfan2020qihang2021';
      //   let reg = /\d+/;
      /*
       lastIndex:当前正则下一次匹配的起始索引位置
      *懒惰性捕获的原因：默认情况下lastIndex的值不会被修改，每一次都是从字符串开始位置查找，所以找到的永远只是第一个
      *解决办法：全局修饰符g
      *
      *
      *
          console.log(reg.lastIndex); //0
      console.log(reg.lastIndex); // =>0 下面匹配捕获是从str索引零的位置开始找
      console.log(reg.exec(str));
      console.log(reg.lastIndex); // 0 第一次匹配捕获完成，lastIndex没有改变，所以下一次exec依然是从字符串最开始找，找到的永远是第一个匹配到的
      */
      //   console.log(reg.exec(str));
      //   reg.lastIndex = 11;
      //   console.log(reg.lastIndex); //1
      //   console.log(reg.exec(str)); //但是结果依然没发生变化 说明手动改没有任何作用

      //   let reg = /\d+/g;
      //   console.log(reg.exec(str)); //=>["2019"...]
      //   console.log(reg.lastIndex); //=>11 设置全局匹配修饰符g后，第一次匹配完，lastIndex会自己修改
      //   console.log(reg.exec(str)); //["2020"...]
      //   console.log(reg.lastIndex); //22

      //   console.log(reg.exec(str)); //["2021"]
      //   console.log(reg.lastIndex); //32

      //   console.log(reg.exec(str)); //null 当全部捕获后，再次捕获的结果是null，但是lastIndex又回归了初始值零，再次捕获又从第一个开始了...
      //   console.log(reg.lastIndex); //0

      //   console.log(reg.exec(str)); //["2019"...]
      //   //!==========
      //   let reg = /\d+/g;
      //   if (reg.test(str)) {
      //     //验证一下：只有正则和字符串匹配我们再捕获
      //     console.log(reg.lastIndex); //=>11 基于test匹配验证后，lastindex已经被修改为第一次匹配后的结果，所以下一次捕获不再从头开始了
      //     console.log(reg.exec(str)); //["2020"...]
      //   }
      //!!!!!!!!!!!!!需求：编写一个方法execAll,执行一次可以把所以匹配的结果捕获到(前提正则一定要设置全局修饰符g)
      //   ~(function () {
      //     function execAll(str = '') {
      //       //=>str 要匹配的字符串
      //       // => this:RegExp的实例(当前操作的正则)
      //       //=>进来后的第一件事，是验证当前正则是否设置了G，不设置则不能在进行循环捕获了，否则会导致死循环
      //       if (!this.global) return this.exec(str);

      //       // ARY存储最后所以捕获的信息 res存储每一次捕获的内容
      //       let ary = [],
      //         res = this.exec(str);
      //       while (res) {
      //         // 把每一次捕获的内容RES[0]存放到数组中
      //         ary.push(res[0]);
      //         //=>只要捕获的内容不为NULL，则继续捕获下去
      //         res = this.exec(str);
      //       }
      //       return ary.length === 0 ? null : ary;
      //     }
      //     RegExp.prototype.execAll = execAll;
      //   })();
      //   let reg = /\d+/g;
      //   let c = reg.execAll('zhufeng2019yangfan2020qihang2021');
      //   console.log(c); //2019 2020 2021
      //   // =>字符串中的match方法,可以在执行一次的情况下，捕获到所有的匹配的数据(前提：正则也得设置G才可以)
      //   console.log('zhufeng2019yangfan2020qihang2021'.match(reg)); //2019 2020 2021
      //   let str = '130828199012040112';
      //   let reg = /^(\d{6})(\d{4})(\d{2})(\d{2})\d{2}(\d)(\d|x)$/;
      //   console.log(reg.exec(str));
      //   console.log(reg.match(str));
      let str = '{0}年{1}月{2}日';
      let reg = /\{\d+\}/;
      console.log(reg.exec(str));

      console.log(str.match(reg));
    </script>
  </body>
</html>
