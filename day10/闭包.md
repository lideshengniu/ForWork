# 1.闭包作用域

！记得一个问题 函数的形参是在和变量提升一起的时候就被赋值了而不是执行代码的时候

1.创建函数

- 开辟一个堆内存
- 把函数体中的代码当作字符串存储进去
- 把堆内存的地址赋值给函数名/变量名
- **函数在哪创建，那么它执行时候所需要查找的上级作用域就是谁**

2.函数执行

- 形成一个全新的私有作用域、执行上下文、私有栈内存(执行一次形成一个，多个之间也不会产生影响)
- 形参赋值and变量提升
- 代码执行（把所属堆内存中的代码拿出来一行一行执行）
- **遇到一个变量，首先看它是否是为私有变量（形参和在私有作用域中声明的变量是私有变量）是私有的就操作之间的变量即可，不是私有的则向上级作用域中查找。。一直找到全局作用域为止=》作用域链查找机制**
- 私有变量和外界的变量没有必然关系，可以理解为被私有栈内存保护起来了，这种机制其实就是**闭包的保护机制**

3.关于堆栈内存释放问题

 函数执行就会形成栈内存（从内存中分配的一块空间），如果内存都不销毁释放，很容易就会导致栈内存溢出（内存爆满，电脑就卡死了）堆栈内存的释放问题就是学习js的核心知识之一

- 堆内存释放问题

  ```js
  如果当前创建的堆内存不被其他东西所占用（浏览器会在空闲的时候，查找每一个内存的引用状况，不被占用的都会自己给回收掉），则会释放
  let obj = {
      name:'珠峰'
  } //不会被销毁因为被obj占用着的
  let oop = obj
  // 此时obj和oop都占用着对象的堆内存，想要释放堆内存，需要手动解除变量和值的关联(null:空对象指针)
  obj = null
  oop = null
  
  ```

- 栈内存

  ```JS
  // 打开浏览器形成的全局作用域是栈内存
  // 手动执行函数形成的私有作用域是栈内存
  // 基于es6中的let/const形成的块作用域也是栈内存
  
  /*
   *全局栈内存：关掉页面的时候才会销毁
   *私有栈内存：
      1.一般情况下，函数只要执行完成，形成的私有栈内存就会被销毁释放掉（排除死递归、出现死循环的模式）
      2.但是一旦栈内存中的某个东西（一般都是堆地址）被私有作用域以外的事物给占用了，则当前私有栈内存不能立即被释放销毁（特点：私有作用域中的私有变量等信息也被保留下来了）=》市面上认为的闭包：函数执行形成不能被释放的私有栈内存，这样的才是闭包
     */
  function fn(){
      //....
  }
  fn() //=>函数执行形成栈内存，执行完成栈内存销毁
  function X(){
      return function(){
          
      }
  }
  let f = x() //f占用了X执行形成的栈内存中一个东西(返回小函数对应的堆),则X执行形成的栈内存不能被释放了
  ```

- ## 

# 2.闭包的两大作用

从性能角度讲，我们真实项目中应该减少堆闭包的使用(因为闭包会产生不释放的栈内存，过多使用容易导致内存溢出或者性能降低)

 1.保护（私有变量和外界没有必然联系）

2.保存（形成不销毁的栈内存，里面的私有变量等信息保存下来了）

# 3.jquery(jq)前端非常经典的

```js
1.jquery 前端非常经典的类库：提供了大量的方法供开发人员使用=》为了防止全局变量污染(解释：导入JQ后，它里面有大量的方法，如果这些方法不保护起来，用户编写的方法很容易和JQ方法名字相同产生冲突，产生冲突可以理解为全局变量污染)JQ中的方法和变量需要用闭包保护起来
(function(global,factory){
    //. ..
    //typeof window!=="undefined"?windowLthis 验证当前所处环境的全局对象是window还是global等
})(typeof window!=="undefined"?window:this,function(window,noGlobal){
    var jquery = function(selector,context){//...
    }
    //=>通过给全局对象增加 jquery和$ 把私有的jquery方法暴露到全局作用域下，供外面使用(等价于return jquery)(外界需要使用函数中的私有内容，我们可以基于window.xxx和return xxx两种方式实现这个需求)
    window.jQuery = window.$ = jquery
})
// =>开始使用JQ
jquery()

在真实项目中，我们一般都要把自己写的内容放到一个闭包中，这样可以有效防止自己的代码和别人的代码产生冲突(全局变量污染：真实项目中是要尽可能减少堆全局变量的使用)如果需要把自己的东西给别人用，基于return 和 window.xxx等方式暴露给别人即可
```

```JS
=>原生js
var xxx = (function(){
    return xxx
})()
(function(){
    window.xxx = xxx
})()

=>jq
$(function(){
    //。。。这样写在某些角度上也是为了减少全局变量
})

```

## 2.基于let/const/class等创建变量会把所在的大括号（除对象的大括号之外）当作一个全新的私有块级作用域